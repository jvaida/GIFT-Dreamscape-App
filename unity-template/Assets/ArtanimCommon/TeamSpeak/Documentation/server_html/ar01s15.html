<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Filetransfer</title><link rel="stylesheet" href="ts3doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><link rel="home" href="index.html" title="TeamSpeak 3 Server SDK Developer Manual"><link rel="up" href="index.html" title="TeamSpeak 3 Server SDK Developer Manual"><link rel="prev" href="ar01s14.html" title="Miscellaneous functions"><link rel="next" href="ar01s16.html" title="FAQ"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><img id="logo" src="images/logo.png"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Filetransfer</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s14.html"><img src="images/prev.png" alt="Prev"></a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s16.html"><img src="images/next.png" alt="Next"></a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="s_filetransfer"></a>Filetransfer</h2></div></div></div><a class="indexterm" name="idp55775072"></a><p>The TeamSpeak SDK includes the ability to support filetransfer, like the regular TeamSpeak server and client offer. The server can function as a file storage, which can be accessed by clients who can up- and download files. Files are stored on the filesystem where the server is running.</p><p>General filetransfer definitions and structures are described in the headers <code class="filename">public_sdk_definitions.h</code> and <code class="filename">server_commands.h</code>, which are required to include if you want to use the filetransfer feature.</p><p>In addition to the standard virtual server properties there are <a class="link" href="ar01s10s03.html#s_filetransfer_properties">extented filetransfer properties</a> available.</p><p>Filetransfer bandwidth statistics can be queried with special <a class="link" href="ar01s10s04.html#s_ft_connection">filetransfer connection properties</a>.</p><div class="literallayout"><p><br>
</p></div><p>The availability of filetransfer in the TeamSpeak server can be controlled by the following function, which should be called right after <code class="function">ts3server_initServerLib</code> to initialize filetransfer.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">ts3server_enableFileManager</b>(</code></td><td><var class="pdparam">filebase</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ips</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">port</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">downloadBandwitdh</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">uploadBandwidth</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>const char* <var class="pdparam">filebase</var></code>;<br><code>const char** <var class="pdparam">ips</var></code>;<br><code>int <var class="pdparam">port</var></code>;<br><code>uint64 <var class="pdparam">downloadBandwitdh</var></code>;<br><code>uint64 <var class="pdparam">uploadBandwidth</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55788944"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>filebase</code></em></p><p>The base folder where to save the files to. If this is initalized to "sdk_files", we would get the following directory structure:
	</p><div class="itemizedlist"><ul type="circle"><li><p>All files for virtual server with id 1 will be in &#8220;<span class="quote">sdk_files/virtualserver_1</span>&#8221;.</p></li><li><p>Files in channel 1 in virtual server 1 will be in &#8220;<span class="quote">sdk_files/virtualserver_1/channel_1</span>&#8221;</p></li><li><p>These directories will automatically be created by the server if they do not exist. It is the responsibility of the application (not serverlib) to delete these directories when they are no longer needed.</p></li></ul></div><p>
	</p></li><li><p><em class="parameter"><code>ips</code></em></p><p>Array of IPs (IPv4 and IPv6 are supported) to bind to. This can be NULL, in which case we bind to &#8220;<span class="quote">0.0.0.0, ::</span>&#8221;. Otherwise pass a NULL-terminated array of strings (IPs, not domainnames).</p></li><li><p><em class="parameter"><code>port</code></em></p><p>Specifies the TCP port used for filetransfer. Free to choose between 1 and 65536. TeamSpeak defaults to 30033.</p></li><li><p><em class="parameter"><code>downloadBandwidth</code></em></p><p>Download limit in bytes/s or <em class="structfield"><code>BANDWIDTH_LIMIT_UNLIMITED</code></em></p></li><li><p><em class="parameter"><code>uploadBandwidth</code></em></p><p>Upload limit in bytes/s or <em class="structfield"><code>BANDWIDTH_LIMIT_UNLIMITED</code></em></p></li></ul></div><div class="literallayout"><p><br>
</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="s_filetransfer_callbacks"></a>Callbacks</h3></div></div></div><p>The serverlib notifies about ongoing filetransfers with an event, which is called everytime a file upload or download has finished:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">void <b class="fsfunc">onFileTransferEvent</b>(</code></td><td><var class="pdparam">data</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code> const struct FileTransferCallbackExport* <var class="pdparam">data</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55806640"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>data</code></em></p><p>Data structure containing values describing the finished filetransfer event:
	</p><div class="itemizedlist"><ul type="circle"><li><p><em class="parameter"><code>clientID</code></em></p><p>ID of the client who triggerd the filetransfer</p></li><li><p><em class="parameter"><code>transferID</code></em></p><p>The local filetransfer ID</p></li><li><p><em class="parameter"><code>remoteTransferID</code></em></p><p>The remote filetransfer ID</p></li><li><p><em class="parameter"><code>status</code></em></p><p>Info on the state of the transfer, defined by the struct <em class="structfield"><code>FileTransferState</code></em>:
		</p><pre class="programlisting">enum FileTransferState {
    FILETRANSFER_INITIALISING = 0,
    FILETRANSFER_ACTIVE,
    FILETRANSFER_FINISHED,
};</pre><p>
		</p></li><li><p><em class="parameter"><code>statusMessage</code></em></p><p>Info on the state in text form</p></li><li><p><em class="parameter"><code>remotefileSize</code></em></p><p>Size of the transfer file</p></li><li><p><em class="parameter"><code>bytes</code></em></p><p>Transferred bytes</p></li><li><p><em class="parameter"><code>isSender</code></em></p><p>True, if the server is sending the file, false if the server is receiving the file.</p></li></ul></div><p>
	</p></li></ul></div><div class="literallayout"><p><br>
</p></div><p>To change the filename or path of a file transfer, the following callback can be implemented. This is optional, when modifying path or name is not required, simply do not implement this callback. When this function is called, default path and name values are already filled in the passed structs.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">onTransformFilePath</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">invokerClientID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">original</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">result</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>anyID <var class="pdparam">invokerClientID</var></code>;<br><code>const struct TransformFilePathExport* <var class="pdparam">original</var></code>;<br><code>struct TransformFilePathExportReturns* <var class="pdparam">result</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55830112"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the virtual server on which the event is called</p></li><li><p><em class="parameter"><code>invokerClientID</code></em></p><p>ID of the client which invoked the file transfer</p></li><li><p><em class="parameter"><code>original</code></em></p><p>Struct <span class="structname">TransformFilePathExport</span>, defining the original file transfer path and name:</p><pre class="programlisting">struct TransformFilePathExport {
    uint64 channel;
    const char* filename;
    int action;
    int transformedFileNameMaxSize;
    int channelPathMaxSize;
};</pre><div class="itemizedlist"><ul type="circle"><li><p><em class="structfield"><code>channel</code></em></p><p>ChannelID if appropriate (not for <em class="structfield"><code>FT_INIT_SERVER</code></em>, where it defaults to 0)</p></li><li><p><em class="structfield"><code>filename</code></em></p><p>Original file name</p></li><li><p><em class="structfield"><code>action</code></em></p><p>Event was called for which action? (See below)</p></li><li><p><em class="structfield"><code>transformedFileNameMaxSize</code></em></p><p>Maximum size of transformedFileName (see result param)</p></li><li><p><em class="structfield"><code>channelPathMaxSize</code></em></p><p>Maximum size of channelPath (see result param)</p></li></ul></div></li><li><p><em class="parameter"><code>result</code></em></p><p>Struct <span class="structname">TransformFilePathExportReturns</span>, target struct where the file transfer path or name can be changed:</p><pre class="programlisting">struct TransformFilePathExportReturns {
    char* transformedFileName;
    char* channelPath;
    int logFileAction;
};</pre><div class="itemizedlist"><ul type="circle"><li><p><em class="structfield"><code>transformedFileName</code></em></p><p>Pointer to string where the transformed filename is located. To change it, overwrite the content of where the pointer points, up to <em class="structfield"><code>original-&gt;transformedFileNameMaxSize</code></em> bytes.</p></li><li><p><em class="structfield"><code>channelPath</code></em></p><p>Pointer to string where the channel path is located. To change it, overwrite the content of where the pointer points, up to <em class="structfield"><code>original-&gt;channelPathMaxSize</code></em> bytes.</p></li><li><p><em class="structfield"><code>logFileAction</code></em></p><p>Set to 0 to not log to logfile, or 1 to log to file. <em class="structfield"><code>VIRTUALSERVER_LOG_FILETRANSFER</code></em> must also be true for logging to happen (see struct <span class="structname">VirtualServerPropertiesSDK</span> in <code class="filename">public_sdk_definitions.h</code>).</p></li></ul></div></li></ul></div><p>Return with <em class="structfield"><code>ERROR_ok</code></em> if there are no errors, or return an other error value.</p><p>When implementing this callback, depending on the state in <em class="structfield"><code>original-&gt;action</code></em> different fields in the <em class="structfield"><code>result</code></em> struct can be modified.</p><p>Possible states for <em class="structfield"><code>original-&gt;action</code></em> are:</p><div class="itemizedlist"><ul type="disc"><li><p><em class="structfield"><code>FT_INIT_SERVER</code></em></p><p>When the virtual server is being is being created. The <em class="structfield"><code>result-&gt;channelPath</code></em> can be changed to create a different folder for the virtual server.</p></li><li><p><em class="structfield"><code>FT_INIT_CHANNEL</code></em></p><p>When a channel is being is being created. The <em class="structfield"><code>result-&gt;channelPath</code></em> can be changed to create a different folder for the channel.</p></li><li><p><em class="structfield"><code>FT_UPLOAD</code></em></p><p>When a file is being uploaded. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed.</p></li><li><p><em class="structfield"><code>FT_DOWNLOAD</code></em></p><p>When a file is being downloaded. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed.</p></li><li><p><em class="structfield"><code>FT_DELETE</code></em></p><p>When a file is being deleted. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed.</p></li><li><p><em class="structfield"><code>FT_CREATEDIR</code></em></p><p>When a folder is being created. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed</p></li><li><p><em class="structfield"><code>FT_RENAME</code></em></p><p>When a file/folder is being renamed. This callback will be called 2 times, first for old, then for new name. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed.</p></li><li><p><em class="structfield"><code>FT_FILELIST</code></em></p><p>Called when a listing of a folder is requested. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed.</p></li><li><p><em class="structfield"><code>FT_FILEINFO</code></em></p><p>Called when file info is requested. Here <em class="structfield"><code>result-&gt;channelPath</code></em> and/or <em class="structfield"><code>result-&gt;transformedFileName</code></em> can be changed.</p></li></ul></div><div class="literallayout"><p><br>
</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="s_ft_permissions"></a>Permissions</h3></div></div></div><p>The follow callbacks can be optionally implemented to control if various filetransfer actions are allowed or denied. If a callback is not implemented, actions are allowed by default.</p><p>If you want to use these functions, include <code class="filename">server_commands.h</code>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to upload a file:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferInitUpload</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftinitupload* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55884224"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the file transfer is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info:</p><pre class="programlisting">struct ClientMiniExport {
    anyID ID;
    uint64 channel;
    const char* ident;
    const char* nickname;
};</pre></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (fileName/fileSize/channelID):</p><pre class="programlisting">struct ts3sc_ftinitupload {
    struct ts3sc_meta_ftinitupload   m; /* message meta data */
    struct ts3sc_data_ftinitupload   d; /* message data */
};

struct ts3sc_data_ftinitupload {
    const char*  fileName;  /* The file name */
    uint64       fileSize;  /* The file size */
    uint64       channelID; /* The channel ID where the file is to be uploaded */
    int          overwrite; /* Set to 1 to overwrite files, 0 to prevent overwrites */
    int          resume;    /* Set to 1 to resume an existing upload, 0 to start new */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to download a file:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferInitDownload</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftinitdownload* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55899056"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the file transfer is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info</p></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (fileName/channelID):</p><pre class="programlisting">struct ts3sc_ftinitdownload {
    struct ts3sc_meta_ftinitdownload   m; /* message meta data */
    struct ts3sc_data_ftinitdownload   d; /* message data */
};

struct ts3sc_data_ftinitdownload {
     const char*  fileName;  /* The file name */
     uint64       channelID; /* The channel ID where the file is to be downloaded from */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to request the file information:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferGetFileInfo</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftgetfileinfo* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55913008"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the file info request is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info</p></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (fileName/channelID):</p><pre class="programlisting">struct ts3sc_ftgetfileinfo {
    struct ts3sc_meta_ftgetfileinfo   m;      /* message meta data */
    struct ts3sc_data_ftgetfileinfo   d;      /* message data */
    int                               r_size; /* items in r */
    struct ts3sc_array_ftgetfileinfo* r;      /* message repeat data */
};

struct ts3sc_data_ftgetfilelist {
     uint64       channelID; /* The channel ID */
     const char*  path;      /* The path where to get the list for */
};

struct ts3sc_array_ftgetfileinfo {
     uint64 channelID;     /* The channel ID where the file is located */
     const char* fileName; /* The file name */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to request a directory listing:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferGetFileList</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftgetfilelist* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55927328"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the file list request is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info</p></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (path/channelID):</p><pre class="programlisting">struct ts3sc_ftgetfilelist {
    struct ts3sc_meta_ftgetfilelist   m; /* message meta data */
    struct ts3sc_data_ftgetfilelist   d; /* message data */
};

struct ts3sc_data_ftgetfilelist {
     uint64       channelID; /* The channel ID */
     const char*  path;      /* The path where to get the list for */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to delete one or more files:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferDeleteFile</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftdeletefile* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55941344"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the file deletion is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info</p></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (channelID/array of filenames):</p><pre class="programlisting">struct ts3sc_ftdeletefile {
    struct ts3sc_meta_ftdeletefile   m;      /* message meta data */
    struct ts3sc_data_ftdeletefile   d;      /* message data */
    int                              r_size; /* items in r */
    struct ts3sc_array_ftdeletefile* r;      /* message repeat data */
};

struct ts3sc_data_ftdeletefile {
     uint64  channelID; /* The channel ID where the file is to be deleted */
};

struct ts3sc_array_ftdeletefile {
     const char* fileName;  /* The file name to be deleted */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to create a directory:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferCreateDirectory</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftcreatedir* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55955392"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the directory creation is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info</p></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (channelID/dirname):</p><pre class="programlisting">struct ts3sc_ftcreatedir {
    struct ts3sc_meta_ftcreatedir   m; /* message meta data */
    struct ts3sc_data_ftcreatedir   d; /* message data */
};

struct ts3sc_data_ftcreatedir {
     uint64       channelID; /* The channel ID where the file is to be uploaded */
     const char*  dirname;   /* The directory name */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p><div class="literallayout"><p><br>
</p></div><p>Control if a client is allowed to rename a file:
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">permFileTransferRenameFile</b>(</code></td><td><var class="pdparam">serverID</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">client</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">params</var><code>)</code>;</td><td> </td></tr></table><div class="paramdef-list"><code>uint64 <var class="pdparam">serverID</var></code>;<br><code>const struct ClientMiniExport* <var class="pdparam">client</var></code>;<br><code>const struct ts3sc_ftrenamefile* <var class="pdparam">params</var></code>;</div><div class="funcprototype-spacer"> </div></div><p>
<a class="indexterm" name="idp55969328"></a></p><div class="itemizedlist"><ul type="disc"><li><p><em class="parameter"><code>serverID</code></em></p><p>ID of the server where the file rename is initiated.</p></li><li><p><em class="parameter"><code>client</code></em></p><p>Summary client info</p></li><li><p><em class="parameter"><code>params</code></em></p><p>Summary file info (fromChannelID/toChannelID/oldFileName/newFileName). Use <em class="structfield"><code>params-&gt;m.has_toChannelID</code></em> to check if <em class="structfield"><code>toChannelID</code></em> is valid (else it is a rename in the same channel)</p><pre class="programlisting">struct ts3sc_ftrenamefile {
    struct ts3sc_meta_ftrenamefile   m; /* message meta data */
    struct ts3sc_data_ftrenamefile   d; /* message data */
};

struct ts3sc_data_ftrenamefile {
     uint64       fromChannelID; /* The channel ID where the file is located now */
     uint64       toChannelID;   /* The channel ID where the file is to be moved to */
     const char*  oldFileName;   /* The current file name */
     const char*  newFileName;   /* The new file name */
};</pre></li></ul></div><p>Return <em class="structfield"><code>ERROR_OK</code></em> if allowed or <em class="structfield"><code>ERROR_permissions_client_insufficient</code></em>/<em class="structfield"><code>ERROR_permissions</code></em>.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s14.html"><img src="images/prev.png" alt="Prev"></a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s16.html"><img src="images/next.png" alt="Next"></a></td></tr><tr><td width="40%" align="left" valign="top">Miscellaneous functions </td><td width="20%" align="center"><a accesskey="h" href="index.html"><img src="images/home.png" alt="Home"></a></td><td width="40%" align="right" valign="top"> FAQ</td></tr></table></div></body></html>
